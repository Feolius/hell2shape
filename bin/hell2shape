#!/usr/bin/env php
<?php

use Feolius\Hell2Shape\Generator\ClassNameStyle;
use Feolius\Hell2Shape\Generator\Generator;
use Feolius\Hell2Shape\Generator\GeneratorConfig;
use Feolius\Hell2Shape\Generator\KeyQuotingStyle;
use Feolius\Hell2Shape\Lexer\Lexer;
use Feolius\Hell2Shape\Lexer\LexerException;
use Feolius\Hell2Shape\Parser\Parser;
use Feolius\Hell2Shape\Parser\ParserException;
use Feolius\Hell2Shape\Version;
use Symfony\Component\Console\Attribute\Option;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\SingleCommandApplication;
use Symfony\Component\Console\Style\SymfonyStyle;

function autoload(): void
{
    $autoloadPaths = [
        // local dev repository
        dirname(__DIR__).'/vendor/autoload.php',
        // dependency
        dirname(__DIR__, 4).'/vendor/autoload.php',
    ];

    $cwd = \getcwd();
    if ($cwd) {
        $autoloadPaths = [...$autoloadPaths,
            // running from project root
            $cwd.'/vendor/autoload.php',
            // running from project bin
            dirname($cwd).'/autoload.php',
        ];
    }

    $autoloadFound = null;
    foreach ($autoloadPaths as $autoloadPath) {
        if (file_exists($autoloadPath)) {
            require_once $autoloadPath;
            $autoloadFound = true;
            break;
        }
    }

    if (!$autoloadFound) {
        $stderr = fopen('php://stderr', 'w');
        if ($stderr) {
            $message = "Unable to find Composer autoload file.\n\n";
            $message .= '- '.\implode("\n- ", $autoloadPaths)."\n\n";
            fwrite($stderr, $message);
        }
        exit(1);
    }
}

(static function (): void {
    autoload();

    (new SingleCommandApplication())
        ->setName('hell2shape')
        ->setVersion(Version::VERSION)
        ->setDescription('Generate PHPStan typings from var_dump output')
        ->setHelp('Reads var_dump output from STDIN and outputs PHPStan type annotations.')
        ->setCode(function (
                SymfonyStyle $io,
            #[Option(description: 'Indentation size (use 0 for single-line output)', name: 'indent', shortcut: 'i')]
            string $indent = '4',
            #[Option(
                description: 'Key quoting style: none, single, or double',
                name: 'quotes',
                shortcut: null,
                suggestedValues: [
                    KeyQuotingStyle::NoQuotes->value,
                    KeyQuotingStyle::SingleQuotes->value,
                    KeyQuotingStyle::DoubleQuotes->value,
                ],
            )
            ]
            string $quotes = KeyQuotingStyle::NoQuotes->value,
            #[Option(
                description: 'Class name style: uqn (unqualified), qn (qualified), or fqn (fully qualified)',
                name: 'class',
                shortcut: 'c',
                suggestedValues: [
                    ClassNameStyle::Unqualified->value,
                    ClassNameStyle::Qualified->value,
                    ClassNameStyle::FullyQualified->value,
                ],
            )
            ]
            string $class = ClassNameStyle::Unqualified->value,
        ): int {
            $stdin = fopen('php://stdin', 'r');
            if ($stdin === false) {
                $io->getErrorStyle()->error('STDIN is not available');
                return Command::FAILURE;
            }
            $input = trim(stream_get_contents($stdin));
            if (empty($input)) {
                $io->getErrorStyle()->error([
                        'No input provided. Please pipe var_dump output to this command.',
                        'Example: php -r \'var_dump($data);\' | bin/hell2shape'
                ]);
                return Command::FAILURE;
            }

            $indent = filter_var($indent, FILTER_VALIDATE_INT, ['options' => ['min_range' => 0]]);
            if ($indent === false) {
                $io->getErrorStyle()->error('Indent option must be non-negative integer.');
                return Command::FAILURE;
            }

            $quotingStyle = KeyQuotingStyle::tryFrom($quotes);
            if ($quotingStyle === null) {
                $quotingOptions = implode(
                    ',',
                    array_map(fn(KeyQuotingStyle $s) => $s->value, KeyQuotingStyle::cases())
                );
                $io->getErrorStyle()->error("Invalid quoting style. Must be one of: {$quotingOptions}");
                return Command::FAILURE;
            }

            $classNameStyle = ClassNameStyle::tryFrom($class);
            if ($classNameStyle === null) {
                $classNameOptions = implode(
                    ',',
                    array_map(fn(ClassNameStyle $s) => $s->value, ClassNameStyle::cases())
                );
                $io->getErrorStyle()->error("Invalid class name style. Must be one of: {$classNameOptions}");
                return Command::FAILURE;
            }

            $config = new GeneratorConfig($quotingStyle, $indent, $classNameStyle);
            try {
                $lexer = new Lexer();
                $tokens = $lexer->tokenize($input);

                $parser = new Parser();
                $ast = $parser->parse($tokens);

                $generator = new Generator($config);
                $result = $generator->generate($ast);

                $io->writeln($result);
                return Command::SUCCESS;
            } catch (LexerException $e) {
                $io->getErrorStyle()->error("Lexer error: {$e->getMessage()}");
                return Command::FAILURE;
            } catch (ParserException $e) {
                $io->getErrorStyle()->error("Parser error: {$e->getMessage()}");
                return Command::FAILURE;
            } catch (\Throwable $e) {
                $io->getErrorStyle()->error("Unexpected error: {$e->getMessage()}");
                return Command::FAILURE;
            }
        })
        ->run();
})();
